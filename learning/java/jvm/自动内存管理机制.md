## 运行时数据区域
java虚拟机在Java程序运行时会把它所管理的区域划分为不通的数据区域。

 ![运行时区域](https://raw.githubusercontent.com/sunnykema/learningBase/master/learning/image/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png?token=ALjGwbysoYUram63P39DJ5ztXZxZvOVLks5cXnfKwA%3D%3D)
 
 
  ### 1. 程序计数器
  当前所有执行的字节码的行号指示器。由于java虚拟机的多线程是线程轮流切换获取时间片的方式实现的。在任何一个确定的时间点，一个处理器只会执行一个线程中的指令。所以，每个线程都应该有自己独立的计数器。 <label style="color:red"> 程序计数器为线程私有。 此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</label>
  
  ### 2. Java虚拟机栈
  线程私有，生命周期与线程相同。 每个方法在创建的同时会创建一个栈帧，用于存放 局部变量表，操作数栈，动态链接和方法出口等信息。 局部变量表存放了编译期可知的各种基本数据类型（int、double、byte、char、short、float、long、boolean）、引用对象（reference类型，它不同于对象本身，可能是指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。其中64位的long和double占用两个局部变量空间。局部变量表所需要的空间在编译期间完成分配。此区域会抛出 StackOverFlowError和OutOfMemoryError异常。
  
  ### 3.本地方法栈
  与Java虚拟机栈作用相似。为虚拟机所使用到的native方法服务、线程私有、会抛出 StackOverFlowError和OutOfMemoryError异常。
  
  ### 4.Java堆
  被所有线程共享的区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放
对象实例。所有的对象实例和数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术会导致一些微妙的变化发生，所有的对象分配在堆上面也渐渐的变得不是那么"绝对"了。通过-Xmx和-Xms来控制对大小。会抛出OutOfMemoryError。

  ### 5.方法区
  线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。HotSpot虚拟机中称为永久代（Permanent Generation），二者并不等价，仅因为hotSpot虚拟机选择把GC分代收集拓展至方法区，或者说用永久代实现方法区。
  
  ### 6.运行时常量池
  为方法区的一部分，用于存放编译期生成的各种字面量和符号引用，这部分的内容将在类加载之后进入方法区的运行时常量池中存放。会抛出OutOfMemoryError异常。                   